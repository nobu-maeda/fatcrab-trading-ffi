namespace FatcrabTrading {};

[Error]
interface FatCrabError {
  TxNotFound();
  TxUnconfirmed();
  Simple(string description);
  N3xb(string description);
  BdkBip39(string description);
  Bdk(string description);
  JoinError(string description);
};

[Enum]
interface Auth {
  None();
  UserPass(string username, string password);
  Cookie(string file);
};

[Enum]
interface Network {
  Bitcoin();
  Testnet();
  Signet();
  Regtest();
};

[Enum]
interface BlockchainInfo {
  Electrum(string url, Network network);
  Rpc(string url, Auth auth, Network network);
};

dictionary RelayInfo {
  string addr;
  string? socket_addr;
};

enum FatCrabOrderType {
  "Buy",
  "Sell",
};

enum FatCrabTradeRspType {
  "Accept",
  "Reject",
};

interface FatCrabOrder {
  constructor(FatCrabOrderType order_type, string trade_uuid, f64 amount, f64 price);
};

interface FatCrabOrderEnvelope {

};

interface FatCrabOfferEnvelope {

};

interface FatCrabTradeRspEnvelope {

};

interface FatCrabPeerEnvelope {

};

[Trait]
interface FatCrabMakerNotifDelegate {
  void on_maker_offer_notif(FatCrabOfferEnvelope offer_envelope);
  void on_maker_peer_notif(FatCrabPeerEnvelope peer_envelope);
};

[Trait]
interface FatCrabTakerNotifDelegate {
  void on_taker_trade_rsp_notif(FatCrabTradeRspEnvelope trade_rsp_envelope);
  void on_taker_peer_notif(FatCrabPeerEnvelope peer_envelope);
};

interface FatCrabBuyMaker {
  [Throws=FatCrabError]
  void trade_response(FatCrabTradeRspType trade_rsp_type, FatCrabOfferEnvelope offer_envelope);
  [Throws=FatCrabError]
  void release_notify_peer();
  [Throws=FatCrabError]
  void trade_complete();
  [Throws=FatCrabError]
  void register_notif_delegate(FatCrabMakerNotifDelegate delegate);
  [Throws=FatCrabError]
  void unregister_notif_delegate();
};

interface FatCrabSellMaker {
  [Throws=FatCrabError]
  void trade_response(FatCrabTradeRspType trade_rsp_type, FatCrabOfferEnvelope offer_envelope);
  [Throws=FatCrabError]
  u32 check_btc_tx_confirmation();
  [Throws=FatCrabError]
  void notify_peer(string fatcrab_txid);
  [Throws=FatCrabError]
  void trade_complete();
  [Throws=FatCrabError]
  void register_notif_delegate(FatCrabMakerNotifDelegate delegate);
  [Throws=FatCrabError]
  void unregister_notif_delegate();
};

interface FatCrabBuyTaker {
  [Throws=FatCrabError]
  void notify_peer(string fatcrab_txid);
  [Throws=FatCrabError]
  u32 check_btc_tx_confirmation();
  [Throws=FatCrabError]
  void trade_complete();
  [Throws=FatCrabError]
  void register_notif_delegate(FatCrabTakerNotifDelegate delegate);
  [Throws=FatCrabError]
  void unregister_notif_delegate();
};

interface FatCrabSellTaker {
  [Throws=FatCrabError]
  void trade_complete();
  [Throws=FatCrabError]
  void register_notif_delegate(FatCrabTakerNotifDelegate delegate);
  [Throws=FatCrabError]
  void unregister_notif_delegate();
};

interface FatCrabTrader {
    constructor(BlockchainInfo info);
    [Name=new_with_keys]
    constructor(string key, BlockchainInfo info);
    [Throws=FatCrabError]
    string wallet_bip39_mnemonic();
    [Throws=FatCrabError]
    u64 wallet_spendable_balance();
    [Throws=FatCrabError]
    string wallet_generate_receive_address();
    [Throws=FatCrabError]
    string wallet_send_to_address(string address, u64 amount);
    [Throws=FatCrabError]
    void wallet_blockchain_sync();
    string nostr_pubkey();
    [Throws=FatCrabError]
    void add_relays(sequence<RelayInfo> relays);
    FatCrabBuyMaker make_buy_order(FatCrabOrder order, string fatcrab_rx_addr);
    FatCrabSellMaker make_sell_order(FatCrabOrder order);
    [Throws=FatCrabError]
    sequence<FatCrabOrderEnvelope> query_orders(FatCrabOrderType order_type);
    FatCrabBuyTaker take_buy_order(FatCrabOrderEnvelope order_envelope);
    FatCrabSellTaker take_sell_order(FatCrabOrderEnvelope order_envelope, string fatcrab_rx_addr);
    [Throws=FatCrabError]
    void shutdown();
};